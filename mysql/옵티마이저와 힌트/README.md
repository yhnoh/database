### 옵티마이저

---

- 옵티마이저는 어떻게 해야 최적이고 최소의 비용으로 쿼리 결과를 도출할지를 결정하는 역할을 한다.
  - 쿼리 결과는 동일할지 몰라도 그 결과를 도출하는 과정은 매우 다양하기 때문이다.
- MySQL에서는 쿼리를 최적으로 실행
  - 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계정보를 참조
  - 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업

### MySQL 쿼리 실행 절차

1. SQL 파싱
   - 사용자로부터 요청한 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
   - `SQL 파싱`을 위해 `SQL 파서`라는 모듈을 이용하고 해당 단계에서 `SQL 파스 트리`가 만들어진다.
   - MySQL 서버는 SQL 문장 그 자체가 `SQL 파스 트리`를 이용해 쿼리를 실행한다. 
2. 최적화 및 실행 계획 수립
   - SQL 파스 트리를 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - 해당 기능은 MySQL 서버의 옵티마이저에서 처리하며 대표적인 작업들은 아래와 같다.
     - 불필요한 조건 및 복잡한 연산의 단순화
     - 여러 테이블의 조인이 있을 경우 어떤 순서로 테이블을 읽을지 결정
     - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
     - 가져온 레코드를 임시 테이블에 넣고 다시 한번 가공해야 하는지 경정
3. 쿼리 결과 가져오기
   - 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로 부터 데이터를 가져온다.
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.


### 풀 테이블 스캔과 풀 인덱스 스캔

- 테이블 풀 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 있는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 조건에 일치하는 레코드 건수가 많은 경우
- 테이블을 처음부터 끝까지 읽는 작업은 인덱스 레인지 스캔을 하는 작업보다 상당히 많은 디스크 읽기가 필요하다.
  - 때문에 풀 테이블 스캔 시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.
- 풀 테이블 스캔이 실행될 시
  - 처음 몇개의 데이터 페이지는 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행한다.
  - 특정 시점부터 읽기 작업을 백그라운드 스레드로 넘겨 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시키명 버퍼 풀에 저장해 둔다. 최대 64개의 데이터 페이지까지 읽을 수 있다.
    - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
    > 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
  - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기 때문에 쿼리가 상당히 빨리 실행된다.
- innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.
- 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB 스토리지 엔진은 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재한다.
- 