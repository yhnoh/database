### 옵티마이저

---

- 옵티마이저는 어떻게 해야 최적이고 최소의 비용으로 쿼리 결과를 도출할지를 결정하는 역할을 한다.
  - 쿼리 결과는 동일할지 몰라도 그 결과를 도출하는 과정은 매우 다양하기 때문이다.
- MySQL에서는 쿼리를 최적으로 실행
  - 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계정보를 참조
  - 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업

### MySQL 쿼리 실행 절차

1. SQL 파싱
   - 사용자로부터 요청한 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
   - `SQL 파싱`을 위해 `SQL 파서`라는 모듈을 이용하고 해당 단계에서 `SQL 파스 트리`가 만들어진다.
   - MySQL 서버는 SQL 문장 그 자체가 `SQL 파스 트리`를 이용해 쿼리를 실행한다. 
2. 최적화 및 실행 계획 수립
   - SQL 파스 트리를 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - 해당 기능은 MySQL 서버의 옵티마이저에서 처리하며 대표적인 작업들은 아래와 같다.
     - 불필요한 조건 및 복잡한 연산의 단순화
     - 여러 테이블의 조인이 있을 경우 어떤 순서로 테이블을 읽을지 결정
     - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
     - 가져온 레코드를 임시 테이블에 넣고 다시 한번 가공해야 하는지 경정
3. 쿼리 결과 가져오기
   - 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로 부터 데이터를 가져온다.
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.


### 풀 테이블 스캔과 풀 인덱스 스캔

- 테이블 풀 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 있는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 조건에 일치하는 레코드 건수가 많은 경우
- 테이블을 처음부터 끝까지 읽는 작업은 인덱스 레인지 스캔을 하는 작업보다 상당히 많은 디스크 읽기가 필요하다.
  - 때문에 풀 테이블 스캔 시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.
- 풀 테이블 스캔이 실행될 시
  - 처음 몇개의 데이터 페이지는 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행한다.
  - 특정 시점부터 읽기 작업을 백그라운드 스레드로 넘겨 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시키명 버퍼 풀에 저장해 둔다. 최대 64개의 데이터 페이지까지 읽을 수 있다.
    - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
    > 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
  - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기 때문에 쿼리가 상당히 빨리 실행된다.
- innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.
- 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB 스토리지 엔진은 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재한다.


### 병렬 처리

- MySQL 8.0 버전 부터는 용도가 한정되어 있지만 MySQL 서버에서도 병렬 처리가가능해 졌다.
- innodb_parallel_read_threads라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.
- 단, 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리가 가능하다.
  - 쿼리를 여러개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없다.
- 병렬 처리용 스레드를 통해서 빠르게 쿼리를 처리할 수는 있느지만, 스레드 개수가 아무리 늘어나더라도 CPU의 코어 개수를 넘어가는 순간부터는 성능이 떨어질 수 있다.


### ORDER BY 처리 (Using filesort)

- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
- 인덱스를 이용한 정렬 튜닝이 안되는 경우
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야하는 경우
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야하는 경우
  - 랜덤하게 결과 레코드를 가져와야하는 경우
- 실행 계획에서 인덱스를 이용하지 않고 정렬 처리를 수행했을 경우, Extra 컬럼에서 Using filesort 메시지가 표시된다.

#### 소트 버퍼
- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.
- 레코드의 크기에 때라 메모리 공간을 가변적으로 할당받지만 최대 사용가능한 소트 버퍼 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.
- 소트 버퍼를 위한 메모리 공간은 실행이 완료되면 즉시 시스템으로 반납한다.
- 만약 소트 버퍼로 할당된 공간보다 크다면 어떻게 될까?
  - MySQL은 정렬해야 할 레콛드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.
  - 소트 버퍼 정렬 수행 -> 임시 디스크 기록 -> 소트 버퍼 정렬 수행 -> 임시 디스크 기록 -> ... 기록된 레코드 병홥하여 반환 (Multi-merge)
  - 임시 디스크를 기록하는 작업은 쓰기와 읽기를 유발하며, 레코드 건수가 많을 수록 반복 작업이 많아진다.
- sort_buffer_size 시스템 변수의 설정 값을 크게 설정하면 처리가 빨라질 것으로 예상하지만 실제 결과는 그렇지 않다.
  - 큰 메모리 공간 할당이 성능을 오히려 떨어트릴 수 있다.
  > 56KB ~ 1MB 미만이 적절 
- 소트 버퍼는 세션 메모리 영역에 해당된다.
  - 때문에 정렬 쿼리가 여러 케넥션에서 동시에 실행되면서 운영체제제는 메모리 부족현상을 겪을 수 있다.
    - 소트 버퍼 메모리 크기를 크게 설정하면 안되는 이유이기도 하다.
  - 이로 인해서 운영체제가 여유 메모리를 확보하기 위해서 프로세스를 강제 종료할 것이다.
> 대량 데이터 정렬이 필요한 경우에는 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리를 실행하고 다시 줄이는 것도 하나의 방법이다.

#### 정렬 알고리즘
- 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라서 2가지 정렬 모드로 나눌 수 있다.