### 옵티마이저

---

- 옵티마이저는 어떻게 해야 최적이고 최소의 비용으로 쿼리 결과를 도출할지를 결정하는 역할을 한다.
  - 쿼리 결과는 동일할지 몰라도 그 결과를 도출하는 과정은 매우 다양하기 때문이다.
- MySQL에서는 쿼리를 최적으로 실행
  - 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계정보를 참조
  - 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업

### MySQL 쿼리 실행 절차

1. SQL 파싱
   - 사용자로부터 요청한 SQL 문장을 잘개 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
   - `SQL 파싱`을 위해 `SQL 파서`라는 모듈을 이용하고 해당 단계에서 `SQL 파스 트리`가 만들어진다.
   - MySQL 서버는 SQL 문장 그 자체가 `SQL 파스 트리`를 이용해 쿼리를 실행한다. 
2. 최적화 및 실행 계획 수립
   - SQL 파스 트리를 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
   - 해당 기능은 MySQL 서버의 옵티마이저에서 처리하며 대표적인 작업들은 아래와 같다.
     - 불필요한 조건 및 복잡한 연산의 단순화
     - 여러 테이블의 조인이 있을 경우 어떤 순서로 테이블을 읽을지 결정
     - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
     - 가져온 레코드를 임시 테이블에 넣고 다시 한번 가공해야 하는지 경정
3. 쿼리 결과 가져오기
   - 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로 부터 데이터를 가져온다.
   - MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.


### 풀 테이블 스캔과 풀 인덱스 스캔

- 테이블 풀 스캔은 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
  - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
  - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 있는 경우
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 조건에 일치하는 레코드 건수가 많은 경우
- 테이블을 처음부터 끝까지 읽는 작업은 인덱스 레인지 스캔을 하는 작업보다 상당히 많은 디스크 읽기가 필요하다.
  - 때문에 풀 테이블 스캔 시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다.
- 풀 테이블 스캔이 실행될 시
  - 처음 몇개의 데이터 페이지는 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행한다.
  - 특정 시점부터 읽기 작업을 백그라운드 스레드로 넘겨 한 번에 4개 또는 8개씩의 페이지를 읽으면서 계속 그 수를 증가시키명 버퍼 풀에 저장해 둔다. 최대 64개의 데이터 페이지까지 읽을 수 있다.
    - InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
    > 리드 어헤드란 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것을 의미한다.
  - 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하기 때문에 쿼리가 상당히 빨리 실행된다.
- innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 리드 어헤드를 시작할지 임계값을 설정할 수 있다.
- 설정된 개수만큼의 연속된 데이터 페이지가 읽히면 InnoDB 스토리지 엔진은 백그라운드 스레드를 이용해 대량으로 그다음 페이지들을 읽어서 버퍼 풀로 적재한다.


### 병렬 처리

- MySQL 8.0 버전 부터는 용도가 한정되어 있지만 MySQL 서버에서도 병렬 처리가가능해 졌다.
- innodb_parallel_read_threads라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.
- 단, 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리가 가능하다.
  - 쿼리를 여러개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없다.
- 병렬 처리용 스레드를 통해서 빠르게 쿼리를 처리할 수는 있느지만, 스레드 개수가 아무리 늘어나더라도 CPU의 코어 개수를 넘어가는 순간부터는 성능이 떨어질 수 있다.


### ORDER BY 처리 (Using filesort)

- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 Filesort라는 별도의 처리를 이용하는 방법이 있다.
- 인덱스를 이용한 정렬 튜닝이 안되는 경우
  - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
  - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야하는 경우
  - UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야하는 경우
  - 랜덤하게 결과 레코드를 가져와야하는 경우
- 실행 계획에서 인덱스를 이용하지 않고 정렬 처리를 수행했을 경우, Extra 컬럼에서 Using filesort 메시지가 표시된다.

#### 소트 버퍼
- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받아 사용하는데, 이 메모리 공간을 소트 버퍼라고 한다.
- 레코드의 크기에 때라 메모리 공간을 가변적으로 할당받지만 최대 사용가능한 소트 버퍼 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.
- 소트 버퍼를 위한 메모리 공간은 실행이 완료되면 즉시 시스템으로 반납한다.
- 만약 소트 버퍼로 할당된 공간보다 크다면 어떻게 될까?
  - MySQL은 정렬해야 할 레콛드를 여러 조각으로 나눠서 처리하는데, 이 과정에서 임시 저장을 위해 디스크를 사용한다.
  - 소트 버퍼 정렬 수행 -> 임시 디스크 기록 -> 소트 버퍼 정렬 수행 -> 임시 디스크 기록 -> ... 기록된 레코드 병홥하여 반환 (Multi-merge)
  - 임시 디스크를 기록하는 작업은 쓰기와 읽기를 유발하며, 레코드 건수가 많을 수록 반복 작업이 많아진다.
- sort_buffer_size 시스템 변수의 설정 값을 크게 설정하면 처리가 빨라질 것으로 예상하지만 실제 결과는 그렇지 않다.
  - 큰 메모리 공간 할당이 성능을 오히려 떨어트릴 수 있다.
  > 56KB ~ 1MB 미만이 적절 
- 소트 버퍼는 세션 메모리 영역에 해당된다.
  - 때문에 정렬 쿼리가 여러 케넥션에서 동시에 실행되면서 운영체제제는 메모리 부족현상을 겪을 수 있다.
    - 소트 버퍼 메모리 크기를 크게 설정하면 안되는 이유이기도 하다.
  - 이로 인해서 운영체제가 여유 메모리를 확보하기 위해서 프로세스를 강제 종료할 것이다.
> 대량 데이터 정렬이 필요한 경우에는 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리를 실행하고 다시 줄이는 것도 하나의 방법이다.

#### 정렬 알고리즘
- 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라서 2가지 정렬 모드로 나눌 수 있다.
- 싱글 패스 정렬 방식
  - 소트 버퍼에 정렬 기준 컬럼과 select되는 대상의 컬럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.
  - 싱글 패스 정렬 방식은 필요한 컬럼을 전부 소트 버퍼에 담기 때문에 많은 메모리가 필요하다.
  - 소트 버퍼 최대 크기를 넘어서 임시 파일에 많은 I/O가 일어날 수 있다.
    - 소트 버퍼 공간의 크기와 레코드 크기에 의존적이다.
  
- 투 패스 정렬 방식
  - 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select할 컬럼을 가져오는 정렬방식이다.
  - 프라이머리키만 소트버퍼에 담기 때문에 적은 소트 버퍼 공간으로도 활용이 가능하지만 테이블을 두번 읽어야하기 때문에 불합리하다.
  - MySQL은 주로 싱글 패스 전략을 사용한다.
  - 투 패스 전략 사용하는 경우
    - 레코드의 크기가 max_length_for_sort_data 시스템 변수에 설정된 값보다 클 경우
    - BLOB이나 TXET 타입의 칼럼이 SELECT 대상에 포함될 때
- 싱글 패스 전략은 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보여준다.
- 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이다. 


#### 정렬 처리 방법

#### 인덱스를 이용한 정렬

- 인덱스를 이용해 정렬이 처리되는 경우에는 실제 인덱스의 값이 정렬돼 있기 때문에 인덱스의 순서대로 읽기만 하면 된다.
- MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수횅하지 않는다.
- join 테이블을 정렬시킬 때 인덱스를 활용하고자 한다면 첫 번째 테이블의 인덱스 컬럼을 정렬로 활용해야 한다.

#### 조인의 드라이빙 테이블만 정렬
- 조인이 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 차선책이다.
  - 이 방법으로 정렬이 처리되려면 조인에서 첫 뻔째로 읽히는 테이블의 컬럼만으로 order by 절을 작성해야 한다.
- 만약 조인 쿼리에서 order by 절이 첫 번째로 읽히는 테이블의 컬럼으로 활용되지 않은 경우는 어떻게 될까?
  - 인덱스를 이용해 첫 번째 테이블의 레코드를 가져온다.
  - 첫 번째 테이블의 레코드는 프라이머리 키를 기준으로 정렬되어 있을 것이다.
  - 첫 번째 테이블의 기준으로 order by 절이 쓰여진 컬럼으로 첫번째 테이블을 정렬한다.
  - on절에 적혀있는 컬럼을 기준으로 조인된 테이블의 레코드를 가져온다.

#### 임시 테이블을 이용한 정렬
- 인덱스 또는 소트 버퍼를 제외한 임시테이블을 이용한 정렬이다.
- 조인의 결과를 임시테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거치기 때문에 앞의 두 정렬에 비해 가장 느린 정렬 방법이다.
- 예를 들어 드라이빙 테이블이 아닌 드리븐 테이블을 이용해 정렬할 경우 발생할 수 있다.
  ```sql
  -- 드리븐 테이블을 이용한 정렬
  select *
  from team t join member m 
  on t.team_id = m.team_id
  order by m.username;
  ``` 
- 쿼리 실행 계획을 보면 Extra 컬럼에 Using temporary: Using filesort라는 코멘트가 표시된다.

#### 정렬 처리 방법의 성능 비교
- 일반적으로 LIMIT는 테이블이나 처리 결과의 일부만 가져오기 때문에 MySQL 서버가 처리해야할 작업량을 줄이는 역할을 한다.
- 그러나 ORDER BY나 GROUP BY 같은 작업은 WHERE 조건을 만족하는 모든 레코드를 가져와서 처리할 수 밖에 없다.
- 때문에 WHERE 조건문에 아무리 인덱스를 잘 활용하도록 튜닝해도 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 자주 발생할 수 있다.
- 쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 왜 느리게 작동되는지 한번 확인해보자.

#### 스트리밍 방식
- MySQL 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식을 의미하다.
- 이 방식으로 처리할 경우 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 전달받는다.
- 스트리밍 방식으로 처리될 수 있다면 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.
- 때문에 쿼리가 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장해준다.
- 


#### 버퍼링 방식
- ORDER BY나 GROUP BY 같은 처리는 쿼리의 결과가 스트리밍되는 것을 불가능하게 한다.
- WHERE 조건에 일치하는 모든 레코드를 가져온 후, 정렬하거난 그루핑해서 차례대로 보내야 하기 때문이다.
- 때문에 MySQL 서버에서는 모든 레코드를 검색하고 정렬하는 작업을 하는 동안 클라이언트는 아무것도 하지 않고 기다려야 하기 때문에 응답 속도가 느려진다.
- 버퍼링 방식으로 처리되는 쿼리는 먼저 결과를 모아서 MySQL 서버에서 일괄 가공해야 하므로 모든 결과를 스토리지 엔진으로 부터 가져올 때까지 기다려야 한다.
- 때문에 버퍼링 방식은 LIMIT처렴 결과 건수를 제한하는 조건이 있어도 성능 향상에 별로 도움이 되지 않는다.
  - 네트워크로 전송되는 레코드 건수를 줄일 수는 있지만 MySQL 서버가 해야 하는 작업량에는 그다지 변화가 없다.
- ORDER BY의 3가지 처리 방법 가운데 인덱스를 사용한 정렬 방식만 스트리밍 형태의 처리이며, 나머지는 모두 버퍼링 후에 정렬된다.
- 가능하면 인덱스를 사용한 정렬을 유도하고, 그렇지 못하다면 최소한 드리이빙 테이블만 정렬해도 되는 수준으로 유도하는 것이 좋은 튜닝 방법이다.


### GROUP BY 처리

- GROUP BY 또한 ORDER BY와 같이 쿼리가 스트리밍된 처리를 할 수 없게 하는 처리 중 하나이다.
- GROUP BY 절에는 HAVING 절을 사용할 수 있는데, HAVING 절은 GROUP BY 결과에 대해 필터링 역할을 수행한다.


- GROUP BY 작업도 인덱스를 사용하는 경우와 그렇지 못한 경우로 나눌 수 있다.
  - 인덱스를 이용할 때는 인덱스를 차례대로 읽는 인덱스 스캔 방법과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔이라는 방법으로 나뉜다.
  - 인덱스를 사용하지 못하는 GROUP BY 작업은 임시 테이블을 사용한다.

#### 인덱스 스캔을 이용하느 GROUP BY

- 조인의 드라이빙 테이블에 속한 컬러만 이용해 그루핑 할 때 GROUP BY 컬럼으로 이미 인덱스가 이싿면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- GROUP BY 인덱스를 사용해서 처리된다 하더라도 그룹함수 등의 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.
- 이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 Extra 컬럼에 별도의 Group BY 관려 코멘트가 따로 표시 되지 않는다.
  - Using index for group-by, Using temporary, Using filesort


#### 루스 인덱스 스캔을 이용하는 GROUP BY
- 루스 인덱스 스캔 방식은 인덱스의 레코드를 건너뚜미녀서 필요한 부분만 읽어서 가져오는 것을 의미한다.
- 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.


#### 임시 테이블을 사용하는 GROUP BY
- GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계없이 인덱스를 전혀 사용하지 못할 때는 임시 테이블을 사용하여 처리한다.
