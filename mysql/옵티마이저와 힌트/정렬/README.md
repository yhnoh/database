### 정렬을 처리하는 방법

### 1. 인덱스를 이용한 정렬
- 인덱스를 이용한 정렬의 경우 인덱스의 값이 정렬되어 있기 때문에, 인덱스를 순서대로 읽기만 하면 되며 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않아도 된다.

#### 1.1. 어떤 인덱스를 사용해야 인덱스를 이용한 정렬이 될까?

- 인덱스를 이용한 정렬의 경우 인덱스의 값이 정렬되어 있기 때문에 따로 MySQL엔진에서 정렬을 수행하지 않아도 된다고 말했다. 그렇다면 어떤 인덱스가 인덱스를 이용한 정렬을 수행할까?
- 그렇다면 모든 인덱스에 해당되는 이야기일까? 실제로 쿼리를 수행해보며 어떤 인덱스가 정렬을 수행하는지 확인해보자. 
```SQL
-- 클러스터링 인덱스를 통한 정렬
explain select * from employees where emp_no between 100000 and 100100 order by emp_no asc;

+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+-----------+
|id|select_type|table    |partitions|type |possible_keys           |key    |key_len|ref |rows|filtered|Extra      |
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+-----------+
|1 |SIMPLE     |employees|null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null|101 |100     |Using where|
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+-----------+

-- 세컨더리 인덱스를 통한 정렬
explain select * from employees where emp_no between 100000 and 100100 order by hire_date asc;

+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+---------------------------+
|id|select_type|table    |partitions|type |possible_keys           |key    |key_len|ref |rows|filtered|Extra                      |
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+---------------------------+
|1 |SIMPLE     |employees|null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null|101 |100     |Using where; Using filesort|
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+---------------------------+
```
- 클러스터링 인덱스를 통해서 정렬 했을 경우 Extra컬럼의 값에 Using filesort 값이 없지만, 세컨더리 인덱스를 통한 정렬을 수행할 경우 Using filesort 값이 있는 것을 확인할 수 있다.
- 클러스터링 인덱스의 경우 물리적으로 정렬이 되어 있지만, 세컨더리 인덱스의 경우 물리적으로 정렬되어 있지는 않기 때문에 위와 같은 결과가 나온 것이 아닐까라는 생각이 든다.

#### 인덱스를 이용한 정렬을 수행하기 위한 조건
1. order by에 명시된 컬럼의 순서대로 생성된 클러스터링 인덱스가 필요하다.
- 위에서 설명했듯이 클러스터링 인덱스만 정렬이 가능하다는 것을 확인했다.
2. 조인을 사용할 경우 order by에 명시된 컬럼(클러스터링 인덱스)이 드라이빙 테이블에 속해야한다.

```SQL
explain select * from employees e left join salaries s on e.emp_no = s.emp_no where e.emp_no between 100000 and 100100 order by e.emp_no;
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+
|id|select_type|table|partitions|type |possible_keys           |key    |key_len|ref               |rows|filtered|Extra      |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+
|1 |SIMPLE     |e    |null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null              |101 |100     |Using where|
|1 |SIMPLE     |s    |null      |ref  |PRIMARY                 |PRIMARY|4      |employees.e.emp_no|9   |100     |null       |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+

explain select * from employees e left join salaries s on e.emp_no = s.emp_no where e.emp_no between 100000 and 100100 order by e.emp_no, from_date;
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
|id|select_type|table|partitions|type |possible_keys           |key    |key_len|ref               |rows|filtered|Extra                                       |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
|1 |SIMPLE     |e    |null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null              |101 |100     |Using where; Using temporary; Using filesort|
|1 |SIMPLE     |s    |null      |ref  |PRIMARY                 |PRIMARY|4      |employees.e.emp_no|9   |100     |null                                        |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
```
- 위 쿼리에서 확인해본바와 같이 조인 사용시 드리븐 테이블에서의 컬럼을 통해서 정렬을 수행할 경우 Extra 컬럼의 값이 Using temporary; Using filesort인 것을 확인할 수 있다.

### Filesort 이용한 정렬
- 인덱스를 이용한 정렬을 사용할 수 없는 경우, Filesort를 이용한 정렬을 수행한다.
- Filesort를 이용한 정렬 작업은 sort_buffer_size 시스템 변수에 명시된 크기 이내에서 정렬이 수행될 경우 메모리를 활용하고, 만약 크기가 크다면 임시 디스크 파일을 사용한다. 
  - 때문에 많은 레코드 정렬을 피하기 위해서는 페이징 처리나, 조건절을 통해서 레코드 양을 줄여주는 것이 좋다.
- 
- 데이터 양이 작은 경우 정렬 기능을 수행하는 데 있어 큰 문제는 없지만, 데이터 양이 큰 경우 임시 디스크와 메모리를 함께 사용함으로 인해서 느려질 수 있다.
- 인덱스를 이용한 정렬에서 확인해 봤듯이, 모든 인덱스가 인덱스를 이용한 정렬을 수행할 것 같지만 실제로는 클러스터링 인덱스만이 인덱스를 이용한 정렬을 수행한다는 것을 확인하였다.
- 때문에 주로 단일 테이블에서 세컨더리 인덱스를 통한 정렬이나 인덱스가 아닌 컬럼에서 filesort를 이용한 정렬이 수행된다.


> https://dev.mysql.com/doc/refman/8.2/en/order-by-optimization.html

### 3. 임시테이블을 이용한 정렬

- 하나의 테이블로부터 SELECT해서 정렬하는 경우라면 임시 테이블이 필요하지 않을 수 있다.
- 하지만 테이블을 조인해서 그 결과 값들을 정렬해야 한다면 임시테이블이 필요할 수 있다.
  - 드라이빙 테이블의 인덱스를 이용한다면 임시테이블을 사용하지 않지만 그 이외의 경우에는 임시테이블을 사용한다.
- Extra 컬럼에 Using temporary; Using filesort라는 값이 표시가 된다.
- 드리븐 테이블을 이용하여 정렬 기준 컬럼이되면 정렬을 수행하기 전에 드리븐 테이블을 읽을 수 밖에 없다ㅏ.
- 

### 소트 버퍼 (Sort Buffer)
- MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당 받는데, 이 메모리 공간을 소트 버퍼라고 한다.
  - 레코드의 크기에 따라서 가변적으로 증가하지만 최대 사용 가능한 소트 버퍼의 공간은 sort_buffer_size라는 시스템 변수로 설정할 수 있다.
- 최대 사용 가능한 소트 버퍼 사이즈 내에서 정렬을 한다면 아주 빠르겠지만, 만약 최대 사용 가능한 사이즈를 초과하게 된다면, 정렬해야 할 레코드를 여로 조각으로 나누며 이 과정에서 임시 저장을 위해 디스크를 사용한다.
  - 버퍼 사이즈 만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야한다. 이 병합 적업을 멀티 머지라고 표현한다.
  - 해당 작업은 디스크 I/O를 유발하며 쿼리 수행 시간에 영향을 미칠 수 있다.
- 소트 버퍼는 클라이언트가 공유할 수 있는 영역이 아닌 세션 메모리 영역에 해당되며 정력 작업이 많아지면 소트 버퍼로 소비되는 메모리 공간이 커짐을 의미한다.
  - 쿼리가 여러 커넥션에서 동시 실행되면서 운영체제는 메모리 부족 현상을 겪을 수 있다.

### 정렬 알고리즘
- 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 정렬 기준 컬럼만 소트 버퍼에 담을지에 따라서 정렬 모드를 나눌 수 있다.
- 싱글 패스 정렬 방식
- SELECT 대상이 되는 컬럼 전부를 소트 버퍼에 담아서 정렬을 수행하는 방식을 싱글 패스 정렬 방식이라고 한다.
- 테이블을 한번만 읽으면되서 효율적으로 보이지만, 소트 버퍼의 최대 사용 가능한 사이즈를 쉽게 초과할 가능성이 있으며 이로 인해서 메모리 부족 현상을 겪을 수 있다.
- 투 패스 정렬 방식
- 정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 SELECT할 컬럼을 가져오는 정렬 방식을 투 패스 정렬 방식이라고 한다.
- 투 패스 정렬 방식은 테이블을 두번 읽어야 하기 때문에 상당히 불합리해 보이지만, 소트 버퍼 공간을 적게 사용하며 멀티 머지가 일어날 가능성을 줄인다.
- 최신 MySQL 서버는 주로 싱글 패스 정렬 방식을 사용하지만, 특정 상황에서는 싱글 패스 정렬 방식을 사용하지 못한다.