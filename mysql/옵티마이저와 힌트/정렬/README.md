## 1. ORDER BY 처리
- SELECT 쿼리에서는 정렬이 필수적으로 사용되며, ORDER BY절을 생략하였더라도 클러스터링 인덱스를 통해서 정렬된 결과를 클라이언트에게 응답한다.
- 정렬을 처리하는 방법은 인덱스를 이용한 정렬, FIlesort를 이용한 정렬, 임시 테이블을 이용한 정렬로 나눌 수 있으며 정렬 방식에 대한 이해가 있어야 나중에 슬로우 쿼리를 해결할 수 있다.

### 1.1. 인덱스를 이용한 정렬
- 인덱스를 이용한 정렬의 경우 인덱스의 값이 정렬되어 있기 때문에, 인덱스를 순서대로 읽기만 하면 되며 MySQL 엔진에서 별도의 정렬을 위한 추가 작업을 수행하지 않아도 된다.

#### 1.1.1. 어떤 인덱스를 사용해야 인덱스를 이용한 정렬이 될까?

- 인덱스를 이용한 정렬의 경우 인덱스의 값이 정렬되어 있기 때문에 따로 MySQL엔진에서 정렬을 수행하지 않아도 된다고 말했다. 그렇다면 어떤 인덱스가 인덱스를 이용한 정렬을 수행할까?
- 그렇다면 모든 인덱스에 해당되는 이야기일까? 실제로 쿼리를 수행해보며 어떤 인덱스가 정렬을 수행하는지 확인해보자. 
```SQL
-- 클러스터링 인덱스를 통한 정렬
explain select * from employees where emp_no between 100000 and 100100 order by emp_no asc;

+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+-----------+
|id|select_type|table    |partitions|type |possible_keys           |key    |key_len|ref |rows|filtered|Extra      |
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+-----------+
|1 |SIMPLE     |employees|null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null|101 |100     |Using where|
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+-----------+

-- 세컨더리 인덱스를 통한 정렬
explain select * from employees where emp_no between 100000 and 100100 order by hire_date asc;

+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+---------------------------+
|id|select_type|table    |partitions|type |possible_keys           |key    |key_len|ref |rows|filtered|Extra                      |
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+---------------------------+
|1 |SIMPLE     |employees|null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null|101 |100     |Using where; Using filesort|
+--+-----------+---------+----------+-----+------------------------+-------+-------+----+----+--------+---------------------------+
```
- 클러스터링 인덱스를 통해서 정렬 했을 경우 Extra컬럼의 값에 Using filesort 값이 없지만, 세컨더리 인덱스를 통한 정렬을 수행할 경우 Using filesort 값이 있는 것을 확인할 수 있다.
- 클러스터링 인덱스의 경우 물리적으로 정렬이 되어 있지만, 세컨더리 인덱스의 경우 물리적으로 정렬되어 있지는 않기 때문에 위와 같은 결과가 나온 것이 아닐까라는 생각이 든다.

#### 1.1.2. 인덱스를 이용한 정렬을 수행하기 위한 조건
1. order by에 명시된 컬럼의 순서대로 생성된 클러스터링 인덱스가 필요하다.
- 위에서 설명했듯이 클러스터링 인덱스만 정렬이 가능하다는 것을 확인했다.
2. 조인을 사용할 경우 order by에 명시된 컬럼(클러스터링 인덱스)이 드라이빙 테이블에 속해야한다.

```SQL
explain select * from employees e left join salaries s on e.emp_no = s.emp_no where e.emp_no between 100000 and 100100 order by e.emp_no;
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+
|id|select_type|table|partitions|type |possible_keys           |key    |key_len|ref               |rows|filtered|Extra      |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+
|1 |SIMPLE     |e    |null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null              |101 |100     |Using where|
|1 |SIMPLE     |s    |null      |ref  |PRIMARY                 |PRIMARY|4      |employees.e.emp_no|9   |100     |null       |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+

explain select * from employees e left join salaries s on e.emp_no = s.emp_no where e.emp_no between 100000 and 100100 order by e.emp_no, from_date;
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
|id|select_type|table|partitions|type |possible_keys           |key    |key_len|ref               |rows|filtered|Extra                                       |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
|1 |SIMPLE     |e    |null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null              |101 |100     |Using where; Using temporary; Using filesort|
|1 |SIMPLE     |s    |null      |ref  |PRIMARY                 |PRIMARY|4      |employees.e.emp_no|9   |100     |null                                        |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
```
- 위 쿼리에서 확인해본바와 같이 조인 사용시 드리븐 테이블에서의 컬럼을 통해서 정렬을 수행할 경우 Extra 컬럼의 값이 Using temporary; Using filesort인 것을 확인할 수 있다.

### 1.2. Filesort 이용한 정렬
- 인덱스를 이용한 정렬을 사용할 수 없는 경우, Filesort를 이용한 정렬을 수행한다.
- 실행 계획을 통해서 Extra 컬럼의 값이 Using filesort일 경우 Filesort 정렬이 수행되었다는 것을 확인할 수 있다.
- Filesort를 이용한 정렬 작업은 sort_buffer_size 시스템 변수에 명시된 크기에 따라 메모리나 임시 디스크를 활용하여 정렬을 수행한다.
  - sort_buffer_size 미만의 정렬을 수행할 경우 메모리 내에서 정렬을 수행하게 된다.
  - sort_buffer_size를 초과할 경우 메모리와 임시 디스크를 활용하며, 정렬해야 할 레코드를 여러 조각으로 나누어 임시 디스크에 저장하고, 각 임시 디스크별로 저장된 내용을 다시 병합해 주는 작업이 필요하다. 이러한 병합 작업을 멀티 머지라고 한다. 임시 디스크를 활용한 정렬을 수행할 경우 디스크 I/O를 유발하며 쿼리 수행 시간에 영향을 미칠 수 있다.
  - 때문에 최대한 sort_buffer_size 이내에 정렬이 수행될 수 있도록 조건절이나 페이징 처리를 활용하여 정렬해야하는 레코드 수를 줄여주는 것이 좋다.

#### 1.2.1. sort_buffer_size
- sort_buffer_size는 세션 메모리 영역에 해당하며 여러 커넥션을 통해서 정렬 작업을 하게 되면 사용하는 메모리 공간이 커짐을 의미한다.
  - 때문에 동시에 많은 정렬을 수행하게 될경우 메모리 부족 현상을 겪을 수 있다. 
- Filesort를 이용한 정렬을 수행할 때 단순히 정렬이 느리다는 이유로 sort_buffer_size 시스템 변수의 크기를 늘리게 될경우 MySQL 서버 자체가 문제가 될 수 있으므로 주의해야한다.

> https://dev.mysql.com/doc/refman/8.2/en/order-by-optimization.html

### 1.3. 임시테이블을 이용한 정렬

- 하나의 테이블로부터 나온 결과 값들을 정렬하는 경우라면 임시 테이블이 필요하지 않을 수 있지만, 테이블을 조인해서 나온 결과 값들을 정렬하는 경우라면 임시 테이블이 필요할 수 있다.
  - 임시테이블을 이용한 정렬을 수행하는 경우 Extra컬럼에서 `Using temporary; Using filesort` 값이 나오는 것을 확인할 수 있다.

#### 1.3.1 언제 임시테이블을 이용한 정렬을 수행할까?
- 조인 활용시 임시 테이블을 이용한 정렬을 수행하지 않는 경우는 드라이빙 테이블의 클러스터링 인덱스를 통해서 정렬하는 경우를 제외하고는 임시 테이블을 이용한 정렬을 수행한다.
```sql
-- 드라이빙 테이블의 클러스터링 인덱스를 이용한 정렬 수행
explain select * from employees e left join salaries s on e.emp_no = s.emp_no where e.emp_no between 100000 and 100100 order by e.emp_no;

+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+
|id|select_type|table|partitions|type |possible_keys           |key    |key_len|ref               |rows|filtered|Extra      |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+
|1 |SIMPLE     |e    |null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null              |101 |100     |Using where|
|1 |SIMPLE     |s    |null      |ref  |PRIMARY                 |PRIMARY|4      |employees.e.emp_no|9   |100     |null       |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+-----------+

-- 드리븐 테이블의 클러스터링 인덱스를 이용한 정렬 수행 
explain select * from employees e left join salaries s on e.emp_no = s.emp_no where e.emp_no between 100000 and 100100 order by s.emp_no, s.from_date;

+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
|id|select_type|table|partitions|type |possible_keys           |key    |key_len|ref               |rows|filtered|Extra                                       |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
|1 |SIMPLE     |e    |null      |range|PRIMARY,ix_emp_no_gender|PRIMARY|4      |null              |101 |100     |Using where; Using temporary; Using filesort|
|1 |SIMPLE     |s    |null      |ref  |PRIMARY                 |PRIMARY|4      |employees.e.emp_no|9   |100     |null                                        |
+--+-----------+-----+----------+-----+------------------------+-------+-------+------------------+----+--------+--------------------------------------------+
```
- 임시 테이블을 활용하는 경우 일치하는 레코드를 임시 테이블에 저장한 이후, 임시 테이블에서 정렬을 수행하고 이에 대한 결과를 클라이언트에게 반환하게 된다.



## 2. MySQL 서버가 클라이언트에게 응답하는 방식

### 2.1. 스트리밍 방식
- 서버 쪽애서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될 때무다 바로바로 클라이언트로 전송해주는 방식을 스트리밍 방식이라 한다.
- 스트리밍 방식으로 처리된다면 클라이언트는 MySQL 서버가 일치하는 레코드를 찾는 즉시 전달받기 때문에 동시에 데이터의 가공 작업을 시작할 수 있다.
- 웹 서비스와 같이 OLTP 환경에서 쿼리의 응답 요청에 빠른 응답 시간이 중요한 경우 스트리밍 방식은 좋은 해결책이 될 수 있다.

### 2.2. 버퍼링 방식
- 서버 쪽에서 전체 레코드를 처리하고, 처리하는 도중 정해진 버퍼 크기만큼 클라이언트에게 전송해주는 방식을 버퍼링 방식이라 한다.
- ORDER BY나 GROUP BY 같은 쿼리는 WHERE절에 일치하는 모든 레코드를 가져온후 처리를 진행할 수 밖에 없다.
- 때문에 스트리밍 방식으로 처리가 불가능하여, MySQL에서 레코드를 찾고 ORDER BY 및 GROUP BY를 처리하는 동안 클라이언트는 응답을 기다릴 수 밖에없다.

### 2.3. 애플리케이션 개발 시 MySQL 서버가 클라이언트에게 응답하는 방식이 중요할까?
- 스트리밍 방식과 버퍼링 방식은 클라이언트에 요청에 따라서 MySQL 서버가 응답을 어떻게 처리할지에 대해서 설명을 해준다.
- 스트리밍 방식의 경우 일치하는 레코드를 찾는 즉시 클라이언트에게 결과를 지속적으로 전달하고, 버퍼링 방식의 경우 정해진 버퍼의 크기만큼 클라이언트에게 결과를 전달하는 방식이다.
- 하지만 우리가 개발하고 있는 환경에서는 주로 MySQL 서버에게 바로 요청과 응답을 하는 방식이 아닌 다른 애플리케이션 라이브러리리릍 통해서 MySQL 서버와 통신을 하게 된다. 
  - 대표적으로 JAVA 진영에서는 JDBC를 통해서 데이터베이스에게 요청하고 응답을 하게 된다.
- JDBC를 통해서 `select * from table`과 같은 풀 테이블 스캔을 요청하게 되면 MySQL 서버는 스트리밍 방식으로 처리해서 클라이언트에게 반환하게 된다.
- 하지만 JDBC 내부에서 응답 받은 결과를 버퍼링하여 전체 결과를 개발자에게 응답해주기 때문에 MySQL 서버가 스트리밍 방식으로 데이터를 전달해준다고 하더라도 JDBC를 사용하고 있는 사용자는 빠르게 결과를 전달 받았다는 것을 알 수 없다.
- 때문에 굉장히 큰 테이블에 대해 정렬 기능을 수행해야할 경우 단순히 정렬 대상이 되는 테이블을 통해서만 해결하려고 하면 안되고, 테이블에 조건을 걸어 레코드를 줄이거나, LIMIT-OFFSET 방식의 페이징 방식이 아닌 다른 페이징 방식을 활용하거나, 캐시를 활용하거나 등등... 정렬 문제를 해결하기 위해서 다른 방법들을 고려해야할 필요성이 있다.
- 안그럴 경우 메모리 부족현상으로 인해서 운영체제에서 MySQL 서버를 죽이는 현상이 발생할 수 있다.

> Real MySql 8.0 개발자와 DBA를 위한 MySQL 실전 가이드, 백은비,이성욱, P288-305