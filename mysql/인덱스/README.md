### 1. 인덱스
---

- 데이터베이스 성능이 느린 이유는 디스크 I/O가 발생하기 때문이다.
  - 때문에 최소한의 디스크 I/O를 통해서 데이터를 반환받는 것이 좋다.
  - 즉, 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 처리되는 것이 가장 효율적이며 조회 성능을 끌어올릴 수 있는 방법이다.
> 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다. <br/>데이터를 읽거나 작성할 때, 데이터 헤더의 이동이 많을 수록 속도가 느려진다.
- 인덱스를 이용하면 필요한 데이터를 효율적으로 접근하여, 조회 성능을 끌어올리 수 있다.
  - 그렇기 때문에 데이터베이스의 성능 튜닝은 대부분 인덱스의 튜닝으로 해결할 수 있다.
- 테이블에서 내가 원하는 데이터를 효율적으로 가져오기 위하여 인덱스는 컬럼의 값(키), 해당 레코드가 저장된 주소(값)를 저장하고 이를 통해서 조회 성능을 올려줄 수 있다.

### 1.1. B-Tree 인덱스의 구조
![](./img/index_structure.png)


- 루트 노드(Root Node): 최상위 노드이며 B-Tree의 진입점 역할을 한다.
- 브랜치 노드 (Branch Node): 루트 노드와 리프 노드 사이에 위한 노드들이다. 하위 노드를 찾기위한 역할을 한다.
  - 루트 노드와 브랜치 노드는 하위 노드에 대한 대한 주소값을 가지며, 키값은 하위 노드에 저장된 키값의 범위를 나타낸다.
- 리프 노드 (Leaf Node): 가장 하위에 있는 노드이며, 실제 데이터나 실제 데이터를 찾기 위한 주소값을 가지고 있다. 실제 데이터를 찾기위한 역할을 한다.
  - 리프 노드는 다른 노드들과 다르게 양방향 연결 리스트 구조이다.

### 1.2. B-Tree 인덱스의 특징
1. 정렬된 구조
- B-Tree 인덱스를 통해서 조회할 때 최대한 빠르게 찾을 수 있도록 컬럼들의 값을 주어진 순서로 미리 정렬해서 보관하고 있다.
- 정렬된 구조를 유지하기 위해서 레코드를 쓰는 과정이 복잡하고 느리지만, 이미 정렬되어 있어서 빠르게 레코드를 찾을 수 있다. 
  - 인덱스가 많은 테이블의 경우에 `INSERT, UPDATE, DELETE`문장의 처리가 느려진다.
  - `SELECT` 쿼리에 `WHERE`문에 걸리는 컬럼이라고 해서 무작정 인덱스를 걸지 말아야하는 이유이다. (인덱스 설계의 중요성)
2. 범위 스캔(range scan) 가능
   - 인덱스가 조회 성능을 올리는 가장 큰 이유중 하나가 바로 범위 스캔이다. 
   - 앞서 B-Tree 인덱스는 정렬된 구조를 유지하고 있다고 했다.
   - 이말은 어디서부터 어디까지 읽을 수 있을 지를 알 수 있다는 의미이기도 하다.
     - 1부터 10까지 중복되지만 정렬되지 않은 리스트가 있으면, 5를 찾기 위하여 처음부터 끝까지 읽어들여할 것이다.
     - 하지만 해당 리스트가 정렬되어 있다면 어디서 부터 어디까지 읽어야하는지를 알 수 있다. 
3. 테이블 디스크 공간보다 작은 디스크 공간
   - 인덱스 ***컬럼의 값과 해당 레코드가 저장된 주소를 키와 값을 쌍으로 삼아 인덱스를 저장***하기 때문에, 태이블을 저장하는 데 필요한 디스크 공간보다 작다.


### 1.3. B-Tree 인덱스의 장점
- 정렬된 구조이기 때문에 B-Tree 인덱스를 이용하면 일부만 읽고 멈출 수 있다.
  - 즉, 정렬된 구조 덕분에 범위 스캔(Range Scan)이 가능하다.
- 범위 스캔이 가능하기 때문에 동등(=) 및 범위(<, >, <=, >=, BETWEEN) 검색에 최적화 되어 있다.
  - 리프 노드가 양방향 연결 리스트 구조를 가지기 때문에 범위 검색 시 다시 루트 노드 부터 조회할 필요가 없다. 
- B-Tree는 한쪽 방향으로 쏠리지 않게 트리의 균형이 유지되기 때문에 최악의 경우에도 로그 시간 복잡도(O(log N))로 데이터를 찾을 수 있다.


### 1.4. B-Tree 인덱스의 단점

- 트리가 한쪽으로 쏠리지 않게 균형을 유지하고 정렬을 유지하기 위하여, 데이터를 쓰거나 삭제하는 작업에서 B-Tree 구조가 재구성되어 느리다.
- 인덱스를 잘못 사용할 경우 오히려 검색 속도가 느려질 수 있다.
  - 데이터를 읽어들일 때 인덱스를 사용하는 것이 무조건적으로 성능을 올리 수 있다고 생각할 수 있지만, 이 것은 사실이 아니다.
  - 인덱스를 통해서 검색을 한다는 것은 루트 -> 브랜치 -> 리프 -> 디스크라는 과정을 거치게 됨으로 인해서 실제로는 그렇게 효율적인 검색 방식이 아니다.
  - 많은 데이터를 인덱스를 통해서 처리하는 것이 아닌, 소량의 데이터를 가지고 올 때 인덱스의 효과가 발휘가 된다. 때문에 인덱스 설계는 중요하다.   

### 1.5. 인덱스 분류하기


#### 1.5.1. 인덱스 역할별로 분류
<table>
  <tr>
    <td>프라이머리 키 (Primary Key)</td>
    <td>
    이 인덱스를 가진 컬럼은 테이블에서 해당 레코드를 식별하는 기준값이 된다. <br/>프라이머리 키는 NULL 값을 허용하지 않으며 중복을 허용하지 않는다.
    </td>
  </tr>
  <tr>
    <td>보조 키 (Secondary Key)</td>
    <td>
    프라이머리 키를 제외한 나머지 모든 인덱스를 보조키로 분류된다.
    </td>
  </tr>
</table>


#### 1.5.2. 데이터 중복 허용 여부로 분류

<table>
  <tr>
    <td>유니크 인덱스 (Unique Index)</td>
    <td>
    인덱스 컬럼의 값을 중복 허용하지 않는다.
    </td>
  </tr>
  <tr>
    <td>유니크 하지 않은 인덱스 (Non-Unique Index)</td>
    <td>
    컬럼의 값의 중복을 허용한다.
    </td>
  </tr>
</table>

#### 1.5.3. 인덱스 정렬과 테이블 레코드 정렬이 같은지 여부

<table>
  <tr>
    <td>클러스터 인덱스 (Clustered Index)</td>
    <td>
    인덱스 값의 정렬 기준으로 테이블 레코드가 정렬되어 있는 경우이다.
    </td>
  </tr>
  <tr>
    <td>유니크 하지 않은 인덱스 (Non-Clustered Index)</td>
    <td>
    인덱스 값의 정렬 기준과 테이블 레코드 정렬 기준이 같지 않는 경우이다.
    </td>
  </tr>
</table>



### 1.6. MySQL InnoDB 스토리지 엔진에서 인덱스의 특징
- 다른 스토리지 엔지의 경우에는 리프 노드에 실제 데이터 레코드의 주소 값을 가지고 있다.
- InnoDB 스토리지 엔진에서는 보조 키 리프 노드가 프라이머리 키 값의 주소를 가지고 있으며, 해당 프라이머리 키값을 이용하여 실제 레코드 주소를 찾아가는 방식을 사용하고 있다.
  - 즉, 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키 값을 저장하고 있는 B-Tree를 다시 검색해야 한다. 


### 2. B-Tree 인덱스 추가 및 삭제
---

### 2.1. 인덱스 키 추가

- 인덱스 키 값을 추가하기 위해서는 해당 값을 저장하기위한 적절한 위치를 찾아야 한다. (정렬순서를 지키기 위해서)
- 저장될 위치를 찾게되면 키 값과 주소 정보를 B-Tree의 리프 노드에 저장하게 되는데, 리프 노드가 꽉 차서 더이상 저장할 수 없을 경우에는 리프노드가 분리되며, 이는 상위 브랜치 노드까지 처리의 범위가 넓어질 수 있다.
  - 이러한 작업 때문에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 든다. 
- 해당 작업 비용이 많이 들기 때문에 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다. 
  - 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 B-Tree에 추가하거나 삭제한다. 

### 2.2. 인덱스 키 삭제

- 레코드를 사젝하게 될 경우, 키 값이 저장된 B-Tree의 리프 노드를 찾아서 삭제 마크만 하면 작업이 완료된다.
- 삭제 마킹된 인덱스 키 공간은 그대로 방치하거나 재활용할 수 있다.
- 삭제 마킹은 디스크 I/O가 필요한 작업이며, InnoDB 스토리지 엔진에서는 이 작업이 버퍼링되어 지연 처리될 수도 있다.

### 2.3. 인덱스 키 수정
- B-Tree 인덱스 키 값은 값에 따라서 저장될 리프 노드의 위치(정렬되어 있음)가 결정되기 때문에, 단순히 인덱스상의 키 값만 변경하는 것은 불가능하다.
- 때문에 해당 키값을 삭제한 후, 다시 새로운 키 값을 추가하는 작업을 진행한다.
- 인덱스 키 추가 작업과 삭제 작업을 하기 때문에 InnoDB 스토리지 엔진에서는 수정 작업도 버퍼링되어 지연처리 될 수도 있다.
