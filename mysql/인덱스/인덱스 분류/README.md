


### 클러스터링 인덱스

- 클러스터링 인덱스는 인덱스의 정렬 순서에 따라서 테이블 레코드의 정렬 순서가 정해지는 인덱스를 의미한다. 
  - MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에만 지원하며, 테이블의 프라이머리 키에만 적용되는 내용이다.
- 프라이머리 키 쓰기
  - 프라이머리 키의 값에 따라서 레코드의 저장위치가 결정되기 때문에 일반적인 인덱스의 쓰기 작업보다는 성능이 느리다.
    - 일반적인 인덱스 컬럼의 변경 작업은 B-Tree 인덱스의 저장 위치만 변경할 수 있으며, 체인지 버퍼의 도움을 받아 인덱스 변경의 지연처리도 가능하다.
    - 하지만 프라이머리 키 값의 변경은 중복 체크 때문에 체인지 버퍼의 도움을 받을 수 없으며, B-Tree인덱스의 저장 위치 변경 및 레코드의 저장 위치도 변경해야한다.
      - 해당 작업을 진행하면서 읽기 및 쓰기 잠금이 일어난다.
    - 때문에 프라이머리 키 값은 최대한 변경될 일이 없으며, 유일성을 가진 컬럼으로 지정하는 것이 좋다.
- 프라이머리 키 읽기
  - 쓰기 작업이 느린 대신 읽기 작업에서 
- 세컨더리 인덱스가 프라이머리 키 값을 가지고 있는 이유
  - 
- 프라이머리 키 생성


- InnoDB의 경우 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장 이나 프라이머리 키의 변경이 상대적으로 느리다.
- 클러스터링 인덱스의 리프노드에는 모든 컬럼이 같이 저장되어 있다. 클러스터링 테이블은 그 자체가 하나의 거대한 구조로 관리되는 것이다.
- InnoDB 스토리지 엔진의 경우 인덱스가 프라이머리 키 값을 가지고 이
- 만약 이런 구조가 아니라면 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주소값을 변경해야한다.
- 때문에 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.

프라이머리 키가 없는 경우는 프라이머리 키를 대체할 컬럼을 선택한다.
1. 프라이머리 키가 있으면 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택
    - 프라이머리 키나 유니크 인덱스가 없는 경우 아무 의미 없는 숫자 값으로 클러스터링 되며, 이는 아무 혜택도 주지 못한다.
- 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있으며 많은 장점이 있기 때문에 프라이머리 키를 명시하는 것이 좋다.



### 유니크 인덱스

- 유니크 인덱스는 테이블이나 인덱스에 값이 중복될 수 없는 인덱스를 의미한다.
  - 제약 조건을 가진 인덱스이며 MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
- 유니크 인덱스 읽기
  - 일반적인 인덱스와 유니크 인덱스의 레코드 읽기 작업의 성능 차이는 거의 없다.
  - 레코드 읽기의 성능을 구분하는 것은 디스크 I/O이며, 일반적인 인덱스의 경우에는 중복 값을 허용하기 때문에 더 많은 레코드를 읽어 들여야하기 때문에 느린 것이지 인덱스 자체의 특성 때문에 느린 것은 아니다.
- 유니크 인덱스 쓰기
  - 유니크 인덱스의 쓰기 작업은 일반적인 인덱스 쓰기 작업보다 느리게 작동된다.
    - 유니크 인덱스의 경우 중복 값을 체크하기 위해서 일반적인 인덱스에 비해 읽기 및 쓰기 작업에 대해서 잠금을 걸어야하기 때문이다.
    - 또한 일반적인 인덱스는 인덱스 키의 변경에 대한 많은 자원 소모를 해결하기 위해서 체인지 버퍼를 이용하는데, 유니크 인덱스의 경우에는 중복 값 체크 때문에 인덱스 변경 작업에 대한 지연처리를 할 수 없다.
  - 일반적인 인덱스에 비해서 중복 체크 제약조건을 추가할 수 있는 장점이 있지만, 인덱스 쓰기에 대한 성능 이슈가 발생할 수 있기 때문에 꼭 필요한 경우가 아니라면 생성하지 않는 것이 좋다.
    - 여기서 꼭 필요한 경우랑 중복 체크 제약조건이 필요한 경우를 의미한다.