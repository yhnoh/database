


### 클러스터링 인덱스

- 클러스터링 인덱스는 프라이머리 키에 대해서만 적용되는 내용이다.
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며, 프라이머리 카 값에 의해 레코드의 저장 위치가 결정된다.
    - 인덱스 컬럼을 수정할 경우, 인덱스의 삭제 및 저장으로 인해서 B-Tree 인덱스의 저장 위치만 변경이 되지만, 프라이머리 키의 경우는 레코드의 저장 위치도 변경이 된다.
    - 때문에 프라이머리 키의 변경은 꽤나 큰 비용을 소모하게 될 수 있다.
- InnoDB의 경우 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장 이나 프라이머리 키의 변경이 상대적으로 느리다.
- 클러스터링 인덱스의 리프노드에는 모든 컬럼이 같이 저장되어 있다. 클러스터링 테이블은 그 자체가 하나의 거대한 구조로 관리되는 것이다.
- InnoDB 스토리지 엔진의 경우 인덱스가 프라이머리 키 값을 가지고 이
- 만약 이런 구조가 아니라면 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주소값을 변경해야한다.
- 때문에 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현되어 있다.

프라이머리 키가 없는 경우는 프라이머리 키를 대체할 컬럼을 선택한다.
1. 프라이머리 키가 있으면 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택
    - 프라이머리 키나 유니크 인덱스가 없는 경우 아무 의미 없는 숫자 값으로 클러스터링 되며, 이는 아무 혜택도 주지 못한다.
- 클러스터링 인덱스는 테이블당 단 하나만 가질 수 있으며 많은 장점이 있기 때문에 프라이머리 키를 명시하는 것이 좋다.



### 유니크 인덱스

- 유니크 인덱스는 테이블이나 인덱스에 값이 중복될 수 없는 인덱스를 의미한다.
  - 제약 조건을 가진 인덱스이며 MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없다.
- 인덱스 읽기
  - 일반적인 인덱스와 유니크 인덱스의 레코드 읽기 작업의 성능 차이는 거의 없다.
  - 레코드 읽기의 성능을 구분하는 것은 디스크 I/O이며, 일반적인 인덱스의 경우에는 중복 값을 허용하기 때문에 더 많은 레코드를 읽어 들여야하기 때문에 느린 것이지 인덱스 자체의 특성 때문에 느린 것은 아니다.
- 인덱스 쓰기
  - 유니크 인덱스의 쓰기 작업은 일반적인 인덱스 쓰기 작업보다 느리게 작동된다.
    - 유니크 인덱스의 경우 중복 값을 체크하기 위해서 일반적인 인덱스에 비해 읽기 및 쓰기 작업에 대해서 잠금을 걸어야하기 때문이다.
    - 또한 일반적인 인덱스는 인덱스 키의 변경에 대한 많은 자원 소모를 해결하기 위해서 체인지 버퍼를 이용하는데, 유니크 인덱스의 경우에는 중복 값 체크 때문에 인덱스 변경 작업에 대한 지연처리를 할 수 없다.
  - 일반적인 인덱스에 비해서 중복 체크 제약조건을 추가할 수 있는 장점이 있지만, 인덱스 쓰기에 대한 성능 이슈가 발생할 수 있기 때문에 꼭 필요한 경우가 아니라면 생성하지 않는 것이 좋다.
    - 여기서 꼭 필요한 경우랑 중복 체크 제약조건이 필요한 경우를 의미한다.