### 소트 머지 조인

- 조인 컬럼에 인덱스가 없거나 대량 데이터를 조인하고자 할때 인덱스가 효과적이지 않을때, 옵티마이저는 소트 머지 조인이나 해시 조인을 사용한다.
- 소트 머지 조인의 경우 사용자 요청에 따라 임시 메모리 영역(로컬 메모리 영역) 및 로컬 메모리 영역을 초과할 경우 임시 디스크를 사용하여 조인을 수행한다.
  - 때문에 글로벌 메모리 영역에서 걸리는 불필요한 동기화 매커니즘을 사용하지 않기 때문에 같은 양의 데이터를 읽더라도 로컬 메모리 영역에서 좀 더 빠른 성능을 기대할 수 있다.
  - 하지만 많은 수의 커넥션을 통해서 로컬 메모리 영역을 사용할 경우 메모리 부족 현상이 발생할 수 있는 단점이 있다.
> MySQL은 소트 머지 조인을 제공하지 않고 해시 조인만 제공하는 건지, 아니면 해시 조인 내용에 소트 머지 조인이 포함되어 있는지 확인해볼 필요가 있다.
> 현재 배우는 단계에서는 소트 머지 조인 관련된 내용을 MySQL 공식 문서에서는 찾을 수 없다.

#### 1.1. 소트 머지 조인 처리 과정

- 소트 머지 조인은 두 단계를 통해서 진행된다.
  - 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  - 머지 단계: 정렬한 양쪽 집합을 머지한다.
- 아래 쿼리 실행을 통해서 어떠한 소트 머지 조인의 두 단계를 좀 더 자세히 알아보겠다.

1. 쿼리 실행
```sql
select *
from test_employees e join test_salaries s
on e.emp_no = s.emp_no
where e.hire_date between '1985-01-01' and '1985-01-31';
```

2. 소트 단계
```sql
select *
from test_employees e
order by e.emp_no;

select *
from test_salaries e
order by e.emp_no;
```
- 소트 단계에서 조인 컬럼을 기준으로 정렬을 수횅한다.
- 정렬된 결과물은 로컬 메모리 영역에 저장하며, 만약 로컬 메모리 영역을 초과하는 데이터일 경우에는 임시 디스크를 활용하여 저장한다.

3. 머지 단계
```java
for (e in test_employees) {
    for (s in test_salaries) {
        if(e.emp_no == s.emp_no) {
            // 해당 행이 조인을 만족
            break;
        }
    }
}
```
- 머지 단계는 NL 조인과 크게 다르지 않으며, 조인 대상이 되는 두 테이블이 이미 조인컬럼을 기준으로 정렬되어 있기 때문에 드리븐 테이블을 매번 풀 스캔할 필요가 없다.

#### 1.2. 소트 머지 조인이 빠른 이유
- 소트 머지 조인은 정렬과 머지 단계를 통해서 마치 인덱스를 이용한 NL 조인과 거의 비슷하게 처리된다.
- NL 조인 소량 데이터를 읽을 때 효과적이지만 몇몇 단점이 존재한다.
  - 엑세스 하는 모든 블록을 랜덤 엑세스 방식
  - DB 버퍼 캐시, 인덱스 및 테이블을 경유하게 되면서 발생하는 탐색 비용 및 동기화 매커니즘 작동
  - 인덱스를 이용하기 때문에 대량 데이터 조회시 인덱스 손익분기점 한계 발생
- 반면 소트 머지 조인은 로컬 메모리 공간을 활용하기 때문에 동기화 매커니즘 과정이 없다.
  - 소트 머지 조인도 소트 단계에서 양쪽 테이블로 부터 조인 대상을 읽을 때는 DB 버퍼 캐시, 인덱스를 이용하기도 하며 이때 발생하는 탐색 비용은 소트 머지 조인도 피할 수 없다.


> 친절한 SQL 튜닝, 조시형, 부분범위 처리 활용 P274-281 <br/>
> https://coding-factory.tistory.com/757


