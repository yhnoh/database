### 소트 머지 조인

- 조인 컬렘에 인덱스가 없을 때, 대량 데이터를 조인하고자 할때 인덱스가 효과적이지 않을때, 옵티마이저는 소트 머지 조인이나 해시 조인을 사용한다.
- 소트 머지 조인의 경우 공유 메모리 영역을 사용하지 않고, 세션 메모리 영역과 세션 메모리 영역의 사용량이 커졌을 때 임시 디스크를 활용하여 조인을 수행한다.
- 때문에 공유 메모리 영역에서 걸리는 불필요한 락이 걸리지 않기 때문에 대량 데이터를 조인하고자할때 유리하게 사용될 수 있다.

> MySQL은 소트 머지 조인을 제공하지 않고 해시 조인만 제공하는 건지, 아니면 해시 조인 내용에 소트 머지 조인이 포함되어 있는지 확인해볼 필요가 있다.
> 현재 배우는 단계에서는 소트 머지 조인 관련된 내용을 MySQL 공식 문서에서는 찾을 수 없다.

#### 1.1. 소트 머지 조인 처리 과정

- 소트 머지 조인은 두 단계를 통해서 진행된다.
  - 소트 단계: 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
  - 머지 단계: 정렭한 양쪽 집합을 머지한다.

- 해당 쿼리 실헁시 어떤
```sql
select *
from test_employees e join test_salaries s
on e.emp_no = s.emp_no
where e.hire_date between '1985-01-01' and '1985-01-31';
```

- 소트 단계
```sql
select *
from test_employees e
order by e.emp_no;

select *
from test_salaries e
order by e.emp_no;
```

- 머지 단계
```java
for (e in test_employees) {
    for (s in test_salaries) {
        if(e.emp_no == s.emp_no) {
            // 해당 행이 조인을 만족
            break;
        }
    }
}
```

- 머지 단계는 NL조인이 수행하는 단계와 거의 비슷하다.
- `test_employees`와 `test_salaries` 테이블이 이미 소트 단계에서 정렬이 되어 있기 때문에 조인이 실패하는 순간 멈출 수 있다.
  - 마치 인덱스를 이용한 NL 조인과 거의 비슷하게 처리된다.
- NL 조인 과정은에서는 엑세스 하는 모든 블록을 랜덤 엑세스 방식으로 건건이 DB 버퍼 캐시를 경유해서 읽는다. 즉 인덱스든 테이블이든 읽는 모든 블록에 래치 획득 및 캐시 스캔 과정을 거친다.
- 인덱스를 이용하기 때문에 인덱스 손익분기점 한계를 그대로 드러낸다. 이것이 대량 데이터 조인에 NL 조인이 불리한 이유다.
- 반면 소트 머지 조인은 독립적인 메모리 공간을 활용하기 때문에 래치 획득 과정이 없다. 소트 머지 조인도 양쪽 테이블로 부터 조인 대상 집을 읽을 때는 DB 버퍼 캐시를 경유 한다. 이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼 캐시 탐색 비용과 인덱스하는 소트 머지 조인은 피할 수 없다.


