## 캐시

- 캐시란 ***원본 데이터를 미리 복사해 놓은 임시 저장소***를 의미한다.
- 캐시를 사용하는 이유는 사용자 요청으로 매번 원본 데이터를 가져올 때 시간이 오래 걸리는 상황에서, ***원본 데이터를 캐시에 복사하여 데이터를 가져오게되면 데이터를 가져오는 시간을 단축***시킬 수 있다.

### 캐시 도입시 고려사항
- 캐시를 도입하게 될 경우 성능을 향상시킬 수 있지만, 캐시를 도입하기 위해서는 몇 가지 고려해야할 사항들이 있다.
- 캐시 유지보수 비용
  - 캐시를 도입하게 되면 일반적으로 애플리케이션 서버와 분리되기 때문에 ***캐시 서버에 대한 실질적인 비용이 발생***한다.
  - 캐시 서버를 도입한 이후 ***원본 데이터와의 일관성을 맞추기 위한 개발 비용이 발생***한다.
  - 캐시 서버를 도입한 이후 캐시 서버 장애가 발생한 경우, 서비스 전체에 영향을 줄 수 있기 때문에 ***캐시 서버에 대한 모니터링과 장애 대응이 필요***하다.
- 캐싱할 데이터 선정
  - ***요청 빈도가 높은 데이터를 캐싱***하는 것이 좋다. 
    - 요청 빈도가 낮은 데이터를 캐싱하는 것은 리소스 낭비가 될 수 있다.
  - ***데이터 변경의 빈도가 낮은 데이터를 캐싱***하는 것이 좋다. 데이터 변경 빈도가 높은 경우에도 사용할 수 있지만, 캐시와 원본 데이터간의 불일치를 해소하기 위한 추가적인 개발비용이 발생할 수 있다.
  - ***연산 비용이 높은 데이터를 캐싱***하는 것이 좋다. 연산 비용이 높은 데이터를 캐싱하여 사용할 경우 연산 시간을 단축시킬 수 있다.
- 캐시 저장소 선정
  - 원본 데이터 저장소보다 ***빠르게 데이터를 반환할 수 있는 캐시 저장소***를 선정해야 한다.
  - 캐시의 경우 영구적으로 데이터를 저장하는 것이 아니기 때문에 ***자동으로 만료되는 캐시 저장소를 선정***하는 것이 좋다.
  - 캐시 용량이 가득찰 경우 어떤 데이터를 제거할것인지에 대한 ***캐시 제거 정책(Eviction Policy)을 가진 캐시 저장소를 선정***하는 것이 좋다.
  - 캐시 용량의 제한이 있기 때문에 ***확장 가능한 캐시 저장소를 선정***하는 것이 좋다.

### 캐싱 전략
- 캐싱 전략은 캐시를 어떻게 활용할 것인지에 대한 방법론을 의미한다. 각 비지니스 요건에 맞는 상황별로 어떤 캐싱 전략을 사용할 것인지를 결정하기 위해서는 캐싱전략을 이해하는 것이 중요하다.
- 캐싱 전략은 크게 읽기 전략과 쓰기 전략으로 나눌 수 있으며 읽기 전략과 쓰기 전략을 조합하여 사용할 수 있다.
  - 읽기 전략은 캐시와 원본 데이터 간에 상호작용을 통해서 ***언제 원본 데이터를 캐시에 저장하고 캐시에서 데이터를 반환할지를 결정하는 방법론***이다. 
  - 쓰기 전략은 원본 데이터와 캐시 데이터를 일치시키기 위한 방법론으로 ***데이터간의 불일치(캐시 불일치: Cache Inconsistency)를 방지하기 위한 전략***이다.

#### Look Aside (Cache Aside, Lazy Loading)
- 캐시에서 데이터를 먼저 조회하고, 캐시에 데이터가 없을 경우 (캐시 미스: Cache Miss) 원본 데이터에서 데이터를 가져와 캐시에 저장하는 방식이다. 만약 캐시에 데이터가 있다면 캐시에서 데이터를 반환(캐시 히트: Cache Hit)한다.
  - 이 전략은 ***캐시가 비어있을 때만 원본 데이터에 접근하므로, 캐시가 자주 사용되는 경우 성능을 크게 향상***시킬 수 있다.
  - Cache Miss 상황: 외부 요청 -> 애플리케이션이 캐서 서버에 데이터를 요청 -> Cache Miss로 애플리케이션이 원본 데이터에 접근하여 데이터를 가져옴 -> 애플리케이션이 캐시 서버에 데이터를 저장 -> 애플리케이션이 데이터 반환
  - Cache Hit 상황: 외부 요청 -> 애플리케이션이 캐시 서버에 데이터를 요청 -> Cache Hit로 캐시 서버가 데이터를 반환 -> 애플리케이션이 데이터 반환
- 장점
  - Chche Hit 상황이 잦을 경우 ***캐시에서 데이터를 반환하기 때문에 읽기 성능을 향상***시킬 수 있다.
  - ***캐시 서버가 장애가 나더라도 전체 서비스 장애로 이어지지 않는다.*** 애플리케이션이 캐시 서버에 접근하지 않고 원본 데이터에 직접 접근할 수 있기 때문이다.
- 단점
  - Cache Miss 상황이 잦을 경우 캐시의 효용성이 떨어진다.
  - Cache Miss 상황에서 과한 사용자 요청이 발생할 경우 원본 데이터 서버에 부하가 걸릴 수 있다.
    > Cache Miss 상항에서 원본 서버의 과한 요청을 방지하기 위해서 ***캐시 저장소에 미리 데이터를 저장해 두는 캐시 워밍(Cache Warming) 전략***을 사용할 수 있다.
  - 캐시 서버와 원본 서버간의 데이터 불일치가 발생할 수 있다.

#### Read Through 
- Look Aside 전략과 유사하지만, 원본 데이터의 조회 및 저장을 캐시 서버가 담당하는 방식이다.
  - 애플리케이션은 캐시 서버에만 접근하고, 캐시 서버가 원본 데이터에 접근하여 데이터 저장 및 반환을 한다.
- Read Through 전략은 애플리케이션 코드를 간결하게 만들면서 읽기 성능을 향상시킬 수 있지만, ***캐시 서버와 데이터베이스 간의 의존 관계가 발생하며 캐시 서버 장애시 전체 서비스 장애로 이어질 수 있다.***

#### Write Through
- 데이터 불일치를 해소하기 위하여 ***데이터 쓰기 작업을 할 때 원본 데이터와 캐시 데이터를 동시에 작성하는 방식***이다. 
  - 애플리케이션이 데이터 쓰기 작업을 진행할 때, 해당 데이터를 캐시와 원본에 전부 저장한다. 만약 두 작업중 하나라도 실패하게 된다면 전체 작업이 실패하도록 설계한다.
- 장점
  - 원본 데이터와 캐시 데이터의 일관성을 유지할 수 있으며 데이터 유실의 위험이 적다.
- 단점
  - 쓰기 작업시 원본과 캐시에 동시에 접근해야 하므로, 쓰기 작업의 성능이 저하될 수 있다.
  - 캐시 활용도가 떨어지는 데이터의 경우에도 캐시에 저장되기 때문에 리소스 낭비가 발생할 수 있다.

#### Cache Invalidation
- 데이터 불일치를 해소하기 위하여 ***데이터 쓰기 작업을 할 때 원본 데이터와 관련된 캐시 데이터를 삭제하는 방식***이다.
  - 만약 Look Aside 전략을 사용하고 있다면, 캐시에서 데이터를 삭제한 후 다음 요청에서 원본 데이터에서 데이터를 가져와 캐시에 저장하게 됨으로 데이터의 일관성을 유지할 수 있다.
- Write Through 전략에 비해서 쓰기 작업의 성능을 향상시킬 수 있으며, 캐시 활용도가 떨어지는 데이터의 경우에도 캐시에 저장되지 않기 때문에 리소스 낭비를 줄일 수 있다.

#### Write Behind
- 데이터 쓰기 작업을 할 때 ***캐시 데이터를 먼저 작성한 후, 원본 데이터를 비동기적으로 작성하는 방식***이다.
  - 대량의 쓰기 작업시 원본 데이터 서버의 부하를 줄일 수 있는 방법이며 이후 원본 데이터 서버에 저장되는 데이터가 실시간으로 정확하지 않아도 되는 경우 유용하게 사용할 수 있다.

## 레디스는 왜 캐시로 활용되는가?

### 성능
- 레디스는 인메모리 데이터 저장소로써, 디스크 기반의 데이터베이스에 비해 빠른 읽기/쓰기 속도를 제공한다.

### 캐시 관련 정책
- 레디스는 캐시로서 사용하기에 적합한 다양한 정책을 제공한다.
  - LRU(Least Recently Used): 가장 오랫동안 사용되지 않은 데이터를 제거하는 정책
  - LFU(Least Frequently Used): 가장 적게 사용된 데이터를 제거하는 정책
  - TTL(Time To Live): 데이터에 만료 시간을 설정하여 일정 시간이 지나면 자동으로 삭제하는 정책
- 레디스느 오래전부터 
- 레디스는 인메모리 데이터 저장소로써 관계형 데이터베이스에 비해 빠르게 데이터를 반환할 수 있다.
  - 관계형 데이터베이스의 경우 특정 테이블에서 데이터를 가져오기 위해서는 디스크에 직접 접근해야한다.
  - 반면 레디스는 메모리 기반으로 데이터를 저장하고 있어, 디스크 접근 없이 빠르게 데이터를 읽고 쓸 수 있다.
- 만료 시간
  - 레디스는 각 데이터에 대해 TTL(Time To Live)을 설정할 수 있어, 일정 시간이 지나면 자동으로 데이터를 삭제할 수 있다.
  - 
    - 캐시로서 레디스는 메모리 기반의 데이터 저장소로, 빠른 읽기/쓰기 속도를 제공한다.
    - 레디스는 다양한 데이터 구조를 지원하며, TTL(Time To Live) 설정을 통해 자동으로 만료되는 캐시를 구현할 수 있다.
    - 레디스는 분산 캐시 시스템으로도 사용될 수 있어, 여러 서버 간에 캐시 데이터를 공유할 수 있다.

### 사용성
- 레디스는 Key-Value 형태의 데이터 자장소로써, 다양한 자료구조형 데이터 타입을 제공하고 있다.
- 이러한 자료구조형 데이터 타입은 프로그래밍 언어에서 자주 사용되는 자료구조와 유사하여, 개발자가 쉽게 이해하고 사용할 수 있다.
- 또한 레디스는 다양한 클라이언트 라이브러리를 제공하여, 다양한 프로그래밍 언어에서 쉽게 사용할 수 있다.



### 영속성
- 레디스는 인메모리 데이터 저장소이지만, 데이터를 디스크에 영속적으로 저장할 수 있는 기능을 제공한다.
  - RDB(Redis Database): 주기적으로 데이터를 디스크에 저장하는 방식
  - AOF(Append Only File): 모든 쓰기 작업을 로그 형태로 디스크에 저장하는 방식
- 이를 통해서 레디스 서버 장애가 발생하더라도 데이터를 복구하여 서비스를 지속할 수 있다.
  - 이는 곳 

### 고가용성
- 레디스는 Sentinel과 Cluster를 통한 고가용성을 제공한다.
  - Sentinel: 마스터 노드의 장애를 감지하고, 자동으로 복제본 노드를 마스터로 승격시키는 자동 페일오버 기능을 제공
  - Cluster 모드: 샤딩을 통한 데이터 분산 저장과 자동 페일오버 기능을 제공



> [나무위키 > 캐시](https://namu.wiki/w/%EC%BA%90%EC%8B%9C)
> [📚 캐시(Cache) 설계 전략 지침 💯 총정리](https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EC%BA%90%EC%8B%9CCache-%EC%84%A4%EA%B3%84-%EC%A0%84%EB%9E%B5-%EC%A7%80%EC%B9%A8-%EC%B4%9D%EC%A0%95%EB%A6%AC)