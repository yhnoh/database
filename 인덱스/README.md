- 데이터베이스의 성능 튜닝은 디스크 I/O를 얼마나 줄이느냐가 관건이다.
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 의해 결정된다.
- 데이터베이스 쿼리를 튜닝하는 것은 I/O 자체르르 줄여주는 것이 주 목적이다.
  - 즉 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.
  
### 인덱스란?
---

- 데이터베이스의 테이블에서 모든 데이터를 검색해서 내가 원하는 결과를 가져오려면 시간이 많이 필요하다.
- 그래서 ***칼럼들의 값과 해당 레코드가 저장된 주소를 키와 값을 쌍으로 삼아 인덱스***를 만들어 두는 것이다.
- 또한 최대한 빠르게 찾을 수 있도록 ***칼럼들의 값을 주어진 순서로 미리 정렬해서 보관***한다.
- 정렬된 구조를 유지하기 위해서 ***레코드를 쓰는 과정이 복잡하고 느리지만, 이미 정렬되어 있어서 빠르게 레코드를 찾을 수 있다.***
  - 때문에 인덱스가 많은 테이블의 경우에 `INSERT, UPDATE, DELETE`문장의 처리가 느려진다.
  - `SELECT` 쿼리에 `WHERE`문에 걸리는 컬럼이라고 해서 무작정 인덱스를 걸지 말아야하는 이유이다.  

### 인덱스 분류하기
---

- 인덱스를 역할별로 분류
  - 프로이머리 키 (Primary Key)
    - 이 인덱스를 가진 컬럼은 테이블에서 해당 레코드를 식별하는 기준값이 된다.
    - 프라이머리 키는 NULL 값을 허용하지 않으며 중복을 허용하지 않는다. 
  - 보조 키 (Secondary Key)
    - 프라이머리 키를 제외한 나머지 모든 인덱스를 보조키로 분류된다.
- 인덱스를 데이터 중복 허용 여부로 분류
  - 유니크 인덱스 (Unique Index)
    - 컬럼의 값의 중복을 허용하지 않는다.
  - 유니크 하지 않은 인덱스 (Non-Unique Index)
    - - 컬럼의 값의 중복을 허용한다.
  - 유니크 인덱스에 대해 동등 조건으로 검색한다는 것은 항상 1건의 레코드만 존재한다는 것을 옵티마이저에게 알려주는 효과를 낸다.

- B-Tree 인덱스
- B-Tree는 데이터베이스 인덱싱 알고리즘 가운데 가장 일반적으로 사용되는 알고리즘이다.
- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다.
- B-Tree 인덱스 노드
  - 루트 노드(Root Node): 최상위 노드
  - 리프 노드 (Leaf Node): 가장 하위에 잇는 노드
    - - 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소값을 가지고 있다.
  - 브랜치 노드 (Branch Node): 루트 노드도 아니고 리프 노드도 아닌 중간의 노드

- InnoDB 테이블은 프라미어리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
  - 마치 리프 노드의 실제 데이터 레코를 찾기 위한 주소값과 비슷한 역할을 한다.
- 때문에 어떠한 컬럼이 인덱스가 걸려 있고 이 컬럼을 통해 색인하더라도 프라이머리 키 인덱스를 한번 더 검색한 후 레코드를 색인한다.

- B-Tree 인덱스 추가 및 삭제
- 인덱스 키 추가
  - B-Tree에 저장될 때 테이블의 스토리지 엔진에 따라 새로운 키 값이 즉시 인덱스에 저장될 수도 있고 그렇지 않을 수도 있다.
  - B-Tree에 저장될 때 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야한다.
  - 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-Tree 리프 노드에 저장한다.
  - 리프 노드가 꽉 차서 더는 저정할 수 없을 때는 리프 노드가 분리되야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다.
  - B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려져 있다.
  - 프라이머리 키나 유니크 인덱스의 경우 중복체크가 필요하기 때문에 즉시 B-Tree에 추가하거나 삭제한다.
  - 디스크로부터 인덱스 페이지를 읽고 쓰는 시간이 걸리기 때문에 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 있다.
- 인덱스 키 삭제
  - B-Tree의 인덱스 키값을 삭제하는 경우 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.
  - 삭제된 인덱스 키 공간은 계속 방치하거나 재활용할 수 있다.
  - 삭제로 인한 마킹 작업 또한 디스크 쓰기 작업이 필요하므로 이 작업 역시 디스크 I/O가 필요한 영역이다.
  - InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링 되어 지연처리 될 수 있다.
- 인덱스 키 변경
  - B-Tree 인덱스 키 값이 변경이 되면 단순히 인덱스상의 키 값만 변경하는 것은 불가능한다.
    - 값에 따라서 리프 노드의 위치가 결정되기 때문이다.
  - 때문에 B-Tree 인덱스 키 값의 변경 작업은 먼저 키 값을 삭제한 이후, 새로운 키 값을 추가하는 형태로 처리된다.
- 인덱스 키 검색
  - `INSERT, UPDATE, DELETE` 작업에 대한 추가 비용이 발생하더라도 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서이다.
  - 인덱스 검색을 활용할 수 있는 조건문
    - 값의 앞부분만 일치하는 경우
    - 값이 전부 일치하는 경우
    - 부등호 비교 조건
  - 인덱스 검색을 활용할 수 없는 조건문
    - 인덱스를 구성하는 키 값의 뒷부분만 검색할 경우
    - 인덱스의 키 값이 변형이된 후 비교되는 경우
      - 예를 들어 데이터 타입을 변경하여 검색하는 경우
      - 이미 변형된 값은 인덱스에 존재하는 값이 아니기 때문에 인덱스 검색을 활용할 수 없다.
  - InnoDB 스토리지 엔진은 레코드 잠금을 인덱스 단위로 하기 때문에 인덱스를 통해서 INSERT, DELETE 문을 실행시킬때 해당하는 인덱스를 전부 잠근다.
  - 적절히 사용할 수 있는 인덱스가 없으면 불필요한 레코드를 잠글수도 있다.
    - 심지어 모든 레코드를 잠글 수 있다.
- B-Tree 인덱스를 통한 데이터 읽기
  - 인덱스 레인지 스켄
    - 인덱스 레인지 스캔은 겁색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.
    - 검색하려는 값의 수나 겁색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다.
    - B-Tree의 노드들을 거쳐 리프 노드의 읽기 시작해야할 위치를 찾으면 찾아야할 마지막 값까지 순서대로 읽기 시작한다.
    - 하지만 B-Tree 인덱스의 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어야 하는 경우도 많다.
      - 인덱스의 정렬 순서대로 레코드를 가져온다.
      - 리프 노드에 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다.
        - 레코드 주소로 데이터 파일의 레코드를 읽어오는데 레코드 한 건 한 건 단위로 랜덤 I/O 가 발생한다.
        - 인덱스를 통해서 3건의 레코드 검색 조건에 일치한다면 최대 3번의 랜덤 I/O가 발생한다.
        - 때문에 인덱스를 통해 레코드를 읽는 작업은 비용이 많이 드는 작업이므로 읽어야할 데이터 레코드가 20~25%가 넘으면 인덱스를 통한 읽기 보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.
    - 인덱스 레인지 스캔의 과정
      - 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라고 한다.
      - 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔이라고 한다.
      - 읽어들인 인덱스 키와 레코드를 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.
    - 커버링 인덱스
      - 쿼리가 필요로 하는 데이터에 따라 레코드가 저장된 페이지를 가져와, 최종 레코드를 읽는 작업을 하지 않는 경우가 있다. 이를 커버링 인덱스라고 한다.
    - `SHOW STATUS LIKE 'Handler_%'`
      - Handler_read_first, Handler_read_last는 인덱스 값의 최소값 또는 최대값을을 읽을 때 증가하는 상태값이다.
      - 이 상태 값들은 읽은 레코드의 건수를 의미하는데, 실제 인덱스만 읽어는지 인덱스를 통해 테이블의 레코드를 읽어는지는 구분하지 않는다.

- 인덱스 풀 스캔
  - ***인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔***이고 한다.
    - 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용한다.
  - 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 주로 사용한다.
    - 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
  - 이 방식은 레인지 스캔보다 빠르지 않지만, 테이블 풀 스캔보다는 효율적이다.
    - 테이블 레코드를 직접 읽을 필요가 없기 때문에 적은 디스크 I/O로 쿼리를 처리할 수 있다.
    - 일반적으로 인덱스의 크기가 테이블 자체의 크기보다는 작기 때문에 테이블 풀 스캔보다는 효율적이다.
  - 테이블 풀 스캔보다는 효율적이기는 하지만, 인덱스를 효율적으로 사용한다라고는 장담하지 못한다.

- 루스 인덱스 스캔
  - 루스 인덱스 스캔은 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.
  - 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
  - GROUP BY 또는 집합 함수 가운데 MAX() 또는 MINI() 함수에 대해 최적화를 하는 경우 사용된다.
```sql
-- dept_no, emp_no 두 개의 컬럼이 인덱스가 걸려 있을 때
select dept_no, min(emp_no)
from dept_emp
where dept_no between 'd002' and 'd004'
group by dept_no;
```
- 인덱스내에서 `dept_no asc, emp_no asc` 조합으로 정렬되어 있을 것이다.
- dept_no를 그룹 별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.
- 즉, where 조건에 만족하는 범위 전체의 인덱스를 스캔할 필요가 없다.
- 위의 예시를 통해서 풀이하자면 인덱스 리프 노드를 스캔하면서 불필요한 부분은 그냥 무시하고 필요한 부분만 읽는 루프 인덱스 스캔을 사용하였다.

- 인덱스 스킵 스캔
- 기본적으로 다중 컬럼에 인덱스가 걸려 있을 경우 첫 번째 인덱스를 검색하지 않고 나머지 컬럼을 통해서 검색할 경우 인덱스를 효율적으로 사용할 수 없다.
```sql
-- gender, birth_date 순으로 두개의 컬럼이 인덱스가 걸려있는 경우

-- 인덱스를 효율적으로 사용하지 못하는 쿼리
select * from member where birth_date >= '1965-02-01';

-- 인덱스를 사용하는 쿼리
select * from member where gender='M' birth_date = '1965-02-01';
``` 

- MySQL 8.0 버전 부터는 첫 번째 컬럼을 건너 뛰고, 나머지 컬럼만으로 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입되었다.
- 
```sql
-- 사용자가 길행한 검색 쿼리
select gender, birth_date from member where birth_date >= '1965-02-01';

-- 옵티마이저가 인덱스 스킵 스캔을 이용해 실행해주는 쿼리
select gender, birth_date from member where gender='M' and birth_date >= '1965-02-01';
select gender, birth_date from member where gender='F' and birth_date >= '1965-02-01';
```
- 단점은 존재한다.
  - WHERE 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야 함
  - 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야하 함 (커버링 인덱스)


### 다중 컬럼 인덱스
---

- 실제 서비스용 데이터베이스에서는 2개 이상의 컬럼을 포함하는 인덱스가 많이 나온다.
- 중요한 것은 두 번째 컬럼 부터는 앞의 컬럼에 의존해서 정렬되어 있다는 것이다.
- 따라서 다중 컬럼 인덱스에서는 인덱스 내에서 각 컬럼의 위치가 상당히 중요하다.

### B-Tree 인덱스의 정렬 및 스캔 방향

---

- 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬된다.
- 하나의 순서로 정렬되어 있다고 해서 그 순서로만 인덱스를 읽을 수 있다는 의미는 아니다.
- 거꾸로 끝에서 부터 읽으면 오름차순으로 정렬된 인덱스도 내림차순으로 읽을 수 있다.
  - Double Linked List 구조를 떠올려 보자

- 인덱스의 정렬 
  - 인덱스의 구성하는 각 컬럼의 정렬은 오름차순 또는 내림차순으로 설정할 수 있다.
  - 컬럼 단위로 정렬 순서를 사용할 수 있기 때문에 다중 컬럼 인덱스에서도 정렬을 혼합하여 사용할 수 있다.
    ```sql
    -- 다중 컬럼 인덱스 생성
    create index ix_teamname_username on member (team_name asc, user_name desc)
    ```

- 인덱스의 스캔 방향 
  - 하나의 컬럼에 오름차순으로 생성된 인덱스를 `max`나 `order by desc` 절을 통해서 값을 가져올 때, 인덱스의 처음부터 끝까지 읽어서 값을 가져올까?
    ```sql
    -- 오름차순으로 username 인덱스 생성
    create index ix_username on member (username asc)

    select max(username) from member;
    select * from member order by username desc limit 1;
    ```  
    - 옵티마이저는 내가 사용한 쿼리를 해석하여 인덱스를 거꾸로 읽으면 최단 시간에 값을 가져온다는 것을 이미 알고 있다.
    - 때문에 옵티마이저가 읽기 방향을 전환해서 사용하도록 실행 계획을 만들어낸다.
  - 오름차순으로 생성된 인덱스를 정순으로 읽으면 오름차순으로 정렬된 결과가 나오고, 역순으로 읽으면 내림차순으로 정렬된 상태가 된다.
- 내가 어떤 정렬순으로 인덱스를 생성해였다고 하더라도 역순으로도 인덱스를 스캔할 수 있다는 것이다.


- 인덱스 내림차순


### B-Tree 인덱스의 가용성과 효율성

- 비교 조건의 종류와 효율성
- 인덱스의 특징은 왼쪽 값에 기준해서 오름쪽 값이 정렬되어 있다는 것이다.
  - 예를 들어 하나의 컬럼에 B1234, A1234라는 값이 있을 경우 A1234, B1234 순으로 인덱스가 정렬되어 있을 것이다.
- 따라서 왼쪽 값을 모르면 인덱스의 효과를 얻을 수 없다.
```sql
-- username을 통해서 인덱스 생성
create index ix_username on member (username)

-- 왼쪽 값을 모르기 때문에 인덱스 활용 불가
select * from member where username LIKE '%user'
select * from member where username LIKE '%user%'

-- 왼쪽 값을 알기 때문에 인덱스 활용 가능
select * from member where username LIKE 'user%'

```

<span style="color:red">체인지 버퍼 알아보기</span>